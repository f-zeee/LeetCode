# 1:Find all the Connected Components(CC) in the matrix which is a square so n^2
# 2:Find all CC with only 1 initial infection
# 3a:Find the largest among above
# 3b:If there is a tie, we choose smaller index
 
class UnionFind(object):
    def __init__(self, n): 
        self.parents = list(range(n)) 
        self.sizes = [1] * n 

    def _find_iterative(self, i):
        # 1 path to find the root/actual boss
        root = i
        while self.parents[root] != root:
            root = self.parents[root]
        # 2 updating every node in the path to let then know who is the actual boss/root
        while self.parents[i] != root:
            parent = self.parents[i]
            self.parents[i] = root
            i = parent
        return root

    find = _find_iterative

    def union(self, p, q):
        root_p, root_q = map(self.find, (p, q))
        if root_p == root_q: 
            return
        small, big = sorted([root_p, root_q], key=lambda x: self.sizes[x])
        self.parents[small] = big
        self.sizes[big] += self.sizes[small]    

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n=len(graph)
        uf=UnionFind(n)
        
        #1: find all CC O(n^2)
        #here I am iterating over al the ellemrnts in the adjacency matrix;if there is a connection, we'll do a union
        for i in range(n):
            for j in range(n):
                if graph[i][j]:
                    uf.union(i,j)
        
        #2: count no of initial infected nodes
        infected=collections.defaultdict(lambda:0)
        for i in initial:
            a=uf.find(i)
            infected[a]+=1
            
        #3:
        maxSize, candidate=0, min(initial)
        for i in initial:
            infectionCount=infected[uf.find(i)]
            size=uf.sizes[uf.find(i)]
            if infectionCount != 1:
                continue
            if size>maxSize:
                maxSize=size
                candidate=i
            elif size == maxSize and i<candidate:
                candidate=i
        return candidate
            
                
        
        
        
        
        
        
        
        
        
        
        
        